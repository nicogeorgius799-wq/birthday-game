const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');

// Konstanten für das Spiel
const PLAYER_WIDTH = 20;
const PLAYER_HEIGHT = 20;
const PLAYER_SPEED = 3; // Schnelle Bewegung für schweres Spiel
const OBSTACLE_WIDTH = 30;
const OBSTACLE_HEIGHT = 30;
const OBSTACLE_SPEED_INITIAL = 3; // Startgeschwindigkeit
const OBSTACLE_SPAWN_RATE = 1000; // Häufigkeit in ms (1 Sekunde)
const HIGHSCORE_REDIRECT = 20;
const REDIRECT_URL = 'deine_zielseite.html'; // Passe dies an deine Canvas-Seite an

let player = {
    x: canvas.width / 2 - PLAYER_WIDTH / 2,
    y: canvas.height - PLAYER_HEIGHT - 10,
    width: PLAYER_WIDTH,
    height: PLAYER_HEIGHT,
    dx: 0 // Bewegungsrichtung links/rechts
};

let obstacles = [];
let score = 0;
let gameOver = false;
let obstacleSpeed = OBSTACLE_SPEED_INITIAL;

// Event Listener für die Steuerung (Handy-tauglich: Touch oder Klick)
// Der Spieler bewegt sich automatisch in die Richtung des Klicks/Touchs, solange gehalten
let movingLeft = false;
let movingRight = false;

document.addEventListener('keydown', handleKey);
document.addEventListener('keyup', handleKey);
canvas.addEventListener('touchstart', handleTouchStart);
canvas.addEventListener('touchend', handleTouchEnd);
canvas.addEventListener('mousedown', handleTouchStart);
canvas.addEventListener('mouseup', handleTouchEnd);


function handleKey(e) {
    if (e.type === 'keydown') {
        if (e.key === 'ArrowLeft' || e.key === 'a') movingLeft = true;
        if (e.key === 'ArrowRight' || e.key === 'd') movingRight = true;
    } else if (e.type === 'keyup') {
        if (e.key === 'ArrowLeft' || e.key === 'a') movingLeft = false;
        if (e.key === 'ArrowRight' || e.key === 'd') movingRight = false;
    }
}

function handleTouchStart(e) {
    // Bestimme, ob links oder rechts vom Spieler getippt wurde
    const touchX = e.clientX || e.touches[0].clientX;
    const canvasRect = canvas.getBoundingClientRect();
    const relativeX = touchX - canvasRect.left;

    if (relativeX < player.x) {
        movingLeft = true;
        movingRight = false;
    } else if (relativeX > player.x + player.width) {
        movingRight = true;
        movingLeft = false;
    }
}

function handleTouchEnd(e) {
    movingLeft = false;
    movingRight = false;
}


// Spieler aktualisieren
function updatePlayer() {
    if (movingLeft) player.dx = -PLAYER_SPEED;
    else if (movingRight) player.dx = PLAYER_SPEED;
    else player.dx = 0;

    player.x += player.dx;

    // Kollisionserkennung mit den Rändern
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
}

// Hindernisse erstellen
function createObstacle() {
    const x = Math.random() * (canvas.width - OBSTACLE_WIDTH);
    // Startet leicht außerhalb des Canvas oben
    const y = -OBSTACLE_HEIGHT; 
    obstacles.push({
        x,
        y,
        width: OBSTACLE_WIDTH,
        height: OBSTACLE_HEIGHT
    });
}

// Hindernisse aktualisieren und Kollision prüfen
function updateObstacles() {
    for (let i = 0; i < obstacles.length; i++) {
        let obs = obstacles[i];
        obs.y += obstacleSpeed;

        // Kollision prüfen (AABB Kollision)
        if (
            player.x < obs.x + obs.width &&
            player.x + player.width > obs.x &&
            player.y < obs.y + obs.height &&
            player.y + player.height > obs.y
        ) {
            gameOver = true;
            alert('Game Over! Dein Score: ' + score + '. Versuch es noch einmal!');
            // Spiel zurücksetzen, wenn Game Over
            document.location.reload(); 
        }

        // Wenn Hindernis unten raus ist, entfernen und Score erhöhen
        if (obs.y > canvas.height) {
            obstacles.splice(i, 1);
            i--;
            score++;
            scoreElement.textContent = score;

            // Optional: Spiel schwerer machen, wenn der Score steigt
            if (score % 5 === 0) {
                obstacleSpeed += 0.5;
            }
            
            // Highscore erreicht, weiterleiten
            if (score >= HIGHSCORE_REDIRECT) {
                window.location.href = REDIRECT_URL;
            }
        }
    }
}

// Zeichnen
function drawPlayer() {
    ctx.fillStyle = '#00FF00'; // Grün für den Spieler
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawObstacles() {
    ctx.fillStyle = '#FF0000'; // Rot für die Hindernisse
    obstacles.forEach(obs => {
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
    });
}

// Hauptspielschleife
function gameLoop() {
    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updatePlayer();
    updateObstacles();
    drawPlayer();
    drawObstacles();

    requestAnimationFrame(gameLoop);
}

// Start des Spiels
createObstacle(); // Erstes Hindernis
setInterval(createObstacle, OBSTACLE_SPAWN_RATE); // Regelmäßig neue Hindernisse
gameLoop(); // Start der Schleife